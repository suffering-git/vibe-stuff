
When working with Git, security starts before you even make your first commit. Always ensure that sensitive data such as passwords, API keys, access tokens, private SSH keys, personal information, and proprietary files are never included in your repository. The easiest way to avoid this is by creating a .gitignore file that explicitly lists these files and directories so Git never tracks them. This should include .env files, config files with secrets, build output folders, OS-generated files, and anything containing credentials. If you are unsure whether a file should be tracked, err on the side of excluding it until you confirm it is safe.
Always use SSH for authentication instead of HTTPS with a stored password. Generate an SSH key using ssh-keygen, protect it with a strong passphrase, and store the private key securely on your device. Add the public key to your Git hosting account (GitHub, GitLab, Bitbucket, etc.). Keep your Git client and operating system up to date with the latest patches to avoid vulnerabilities. Avoid cloning repositories from untrusted sources, as malicious scripts in post-install hooks or repository contents could compromise your system.
Before every commit, review what will be included by running git status and git diff. This ensures you know exactly what changes you are uploading. If you accidentally commit sensitive data, remove it immediately using git filter-repo (recommended) or git filter-branch, then rotate or revoke the compromised credentials as soon as possible. Remember that even after you remove something from your repo, it may still exist in remote history or forks.
When collaborating, avoid pushing directly to the main or master branch. Instead, create a feature branch for your changes, push it, and open a pull request for review. This not only prevents unstable code from reaching production but also allows other team members to spot potential security issues. Avoid force pushes unless absolutely necessary, and communicate clearly when you do use them, as they rewrite history and can disrupt others’ work.
If your repository is public, understand that once something is pushed, it is effectively permanent. Even if you delete a file in a later commit, previous versions remain in history, and anyone can retrieve them. For additional protection, consider enabling pre-commit hooks with tools like pre-commit or husky to automatically scan for secrets before they are committed. Services like GitHub Advanced Security or GitGuardian can also detect exposed secrets in your commits.
Keep your Git hosting account secure by enabling two-factor authentication (2FA). Review authorized apps and integrations regularly and remove those you no longer use. Delete old deploy keys or tokens that are no longer needed. Avoid using personal accounts for sensitive organizational repositories; instead, use organization-managed accounts with appropriate access controls.
Be careful with commit messages never write credentials, private URLs, or sensitive internal information in them. Logs and debug output should be sanitized before committing, as they can contain private details. When sharing a repository or snippet for troubleshooting, scrub all sensitive data first.
Security in Git is an ongoing habit. By combining safe local practices, proper authentication, careful review before pushing, and vigilant account management, you can work confidently without risking accidental leaks or compromises. Treat every push as a permanent public record, even if the repo is private, and you’ll avoid most security pitfalls.